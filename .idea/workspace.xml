<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="b9f07ee3-7d48-422e-8842-6de6776735bb" name="Default Changelist" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/me/grison/raytraclj/camera.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/me/grison/raytraclj/camera.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/me/grison/raytraclj/core.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/me/grison/raytraclj/core.clj" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="CodeStyleSettingsInfer">
    <option name="done" value="true" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_BRANCH_BY_REPOSITORY">
      <map>
        <entry key="$PROJECT_DIR$" value="chapter-10" />
      </map>
    </option>
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="ProjectCodeStyleSettingsMigration">
    <option name="version" value="1" />
  </component>
  <component name="ProjectId" id="1aOQBQ5MaZ8x2LOK4xoWH8ElTVB" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showExcludedFiles" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="aspect.path.notification.shown" value="true" />
    <property name="cursive.last.file.extension.C\:/dev/github/raytraclj/src" value="clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="settings.editor.selected.configurable" value="preferences.intentionPowerPack" />
  </component>
  <component name="ReplState" timestamp="1586728766682">{:repl-history {:ide [], :local [{:command &quot;(in-ns 'me.grison.raytraclj.core)&quot;, :offset 33, :ns &quot;user&quot;} {:command &quot;(interpose [100 200] \&quot; \&quot;)&quot;, :offset 25, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(let [nx 200\n      ny 100\n      header (str \&quot;P3\\n\&quot; nx \&quot; \&quot; ny \&quot;\\n255\\n\&quot;)\n      body (clojure.string/join (for [j (range (dec ny) -1 -1)\n                                      i (range 0 nx)\n                                      :let [r (/ i nx)\n                                            g (/ j ny)\n                                            b 0.2\n                                            ir (int (* 255.99 r))\n                                            ig (int (* 255.99 g))\n                                            ib (int (* 255.99 b))]]\n                                  (str ir \&quot; \&quot; ig \&quot; \&quot; ib \&quot;\\n\&quot;)))]\n  {:header header :body body})&quot;, :offset 643, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(let [nx 200\n      ny 100\n      header (str \&quot;P3\\n\&quot; nx \&quot; \&quot; ny \&quot;\\n255\\n\&quot;)\n      pixels (for [j (range (dec ny) -1 -1)\n                   i (range 0 nx)\n                   :let [r (/ i nx)\n                         g (/ j ny)\n                         b 0.2\n                         ir (int (* 255.99 r))\n                         ig (int (* 255.99 g))\n                         ib (int (* 255.99 b))]]\n               (str ir \&quot; \&quot; ig \&quot; \&quot; ib \&quot;\\n\&quot;))]\n  {:header header :body pixels})&quot;, :offset 473, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(ns me.grison.raytraclj.core\n  (:require [me.grison.raytraclj.image :as img]))&quot;, :offset 78, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn ppm-header [width height]\n  (str \&quot;P3\\n\&quot; width \&quot; \&quot; height \&quot;\\n255\\n\&quot;))&quot;, :offset 74, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn pixel-line [line]\n  (str (interpose line \&quot; \&quot;) \&quot;\\n\&quot;))&quot;, :offset 58, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn pixel-line [r g b]\n  (str r \&quot; \&quot; g \&quot; \&quot; b \&quot;\\n\&quot;))&quot;, :offset 52, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(pixel-line 0 1 2)&quot;, :offset 18, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(let [nx 200\n      ny 100\n      header (str \&quot;P3\\n\&quot; nx \&quot; \&quot; ny \&quot;\\n255\\n\&quot;)\n      pixels (for [j (range (dec ny) -1 -1)\n                   i (range 0 nx)\n                   :let [r (int (* 255.99 (/ i nx)))\n                         g (int (* 255.99 (/ j ny)))\n                         b (int (* 255.99 0.2))]]\n               (pixel-line r g b))\n      body (clojure.string/join pixels)]\n  (img/save-jpg (str header body) \&quot;/mnt/c/temp/lol\&quot;))&quot;, :offset 435, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(let [nx 200\n      ny 100\n      header (str \&quot;P3\\n\&quot; nx \&quot; \&quot; ny \&quot;\\n255\\n\&quot;)\n      pixels (for [j (range (dec ny) -1 -1)\n                   i (range 0 nx)\n                   :let [r (int (* 255.99 (/ i nx)))\n                         g (int (* 255.99 (/ j ny)))\n                         b (int (* 255.99 0.2))]]\n               (pixel-line r g b))\n      body (clojure.string/join pixels)]\n  (print (str header body))\n  (img/save-jpg (str header body) \&quot;C:/temp/lol\&quot;))&quot;, :offset 459, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(+ 1 2)&quot;, :offset 7, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn load-ppm [^String path]\n  (println \&quot;Loading PPM: \&quot; path)\n  (with-open [in (io/input-stream (io/file path))]\n    (ImageIO/read in)))&quot;, :offset 137, :ns &quot;me.grison.raytraclj.image&quot;} {:command &quot;(defn save-ppm [^String ppm ^String path]\n  (println \&quot;Saving PPM: \&quot; path)\n  (spit path ppm))&quot;, :offset 92, :ns &quot;me.grison.raytraclj.image&quot;} {:command &quot;(let [nx 200\n      ny 100\n      header (str \&quot;P3\\n\&quot; nx \&quot; \&quot; ny \&quot;\\n255\\n\&quot;)\n      pixels (for [j (range (dec ny) -1 -1)\n                   i (range 0 nx)\n                   :let [r (int (* 255.99 (/ i nx)))\n                         g (int (* 255.99 (/ j ny)))\n                         b (int (* 255.99 0.2))]]\n               (pixel-line r g b))\n      body (clojure.string/join pixels)]\n  (img/save-jpg (str header body) \&quot;C:/temp/lol\&quot;))&quot;, :offset 431, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn save-jpg [^String ppm ^String path]\n  (save-ppm ppm (str path \&quot;.ppm\&quot;))\n  (Thread/sleep 500)\n  (store-jpeg (load-ppm (str path \&quot;.ppm\&quot;)) (str path \&quot;.jpg\&quot;)))&quot;, :offset 160, :ns &quot;me.grison.raytraclj.image&quot;} {:command &quot;(let [nx 200\n      ny 100\n      header (str \&quot;P3\\n\&quot; nx \&quot; \&quot; ny \&quot;\\n255\\n\&quot;)\n      pixels (for [j (range (dec ny) -1 -1)\n                   i (range 0 nx)\n                   :let [r (int (* 255.99 (/ i nx)))\n                         g (int (* 255.99 (/ j ny)))\n                         b (int (* 255.99 0.2))]]\n               (pixel-line r g b))\n      body (clojure.string/join pixels)\n      ppm (str header body)\n      _ (img/save-ppm ppm \&quot;C:/temp/lol\&quot;)\n      img (img/load-ppm \&quot;C:/temp/lol.ppm\&quot;)]\n  (println img)\n  (img/store-jpeg img \&quot;C:/temp/lol.jpg\&quot;))&quot;, :offset 551, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(let [nx 200\n      ny 100\n      header (str \&quot;P3\\n\&quot; nx \&quot; \&quot; ny \&quot;\\n255\\n\&quot;)\n      pixels (for [j (range (dec ny) -1 -1)\n                   i (range 0 nx)\n                   :let [r (int (* 255.99 (/ i nx)))\n                         g (int (* 255.99 (/ j ny)))\n                         b (int (* 255.99 0.2))]]\n               (pixel-line r g b))\n      body (clojure.string/join pixels)\n      ppm (str header body)\n      _ (img/save-ppm ppm \&quot;C:/temp/lol\&quot;)\n      _ (Thread/sleep 1000)\n      img (img/load-ppm \&quot;C:/temp/lol.ppm\&quot;)]\n  (println img)\n  (img/store-jpeg img \&quot;C:/temp/lol.jpg\&quot;))&quot;, :offset 579, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(let [nx 200\n      ny 100\n      header (str \&quot;P3\\n\&quot; nx \&quot; \&quot; ny \&quot;\\n255\\n\&quot;)\n      pixels (for [j (range (dec ny) -1 -1)\n                   i (range 0 nx)\n                   :let [r (int (* 255.99 (/ i nx)))\n                         g (int (* 255.99 (/ j ny)))\n                         b (int (* 255.99 0.2))]]\n               (pixel-line r g b))\n      body (clojure.string/join pixels)\n      ppm (str header body)\n      _ (img/save-ppm ppm \&quot;C:/temp/lol.ppm\&quot;)\n      _ (Thread/sleep 1000)\n      img (img/load-ppm \&quot;C:/temp/lol.ppm\&quot;)]\n  (println img)\n  (img/store-jpeg img \&quot;C:/temp/lol.jpg\&quot;))&quot;, :offset 583, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(img/load-ppm \&quot;C:/temp/lol.ppm\&quot;)&quot;, :offset 32, :ns &quot;user&quot;}], :remote [{:command &quot;(defn hello-ppm []\n  (let [nx 200\n        ny 100\n        header (str \&quot;P3\\n\&quot; nx \&quot; \&quot; ny \&quot;\\n255\\n\&quot;)\n        pixels (for [j (range (dec ny) -1 -1)\n                     i (range 0 nx)\n                     :let [r (int (* 255.99 (/ i nx)))\n                           g (int (* 255.99 (/ j ny)))\n                           b (int (* 255.99 0.2))]]\n                 (pixel-line r g b))\n        body (clojure.string/join pixels)\n        ppm (str header body)]\n    (img/save-jpg ppm \&quot;/mnt/c/temp/first.jpg\&quot;)))&quot;, :offset 499, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(hello-ppm)&quot;, :offset 11, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn ppm-header [width height]\n  (str \&quot;P3\\n\&quot; width \&quot; \&quot; height \&quot;\\n255\\n\&quot;))&quot;, :offset 74, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn string\n  ([v] (string v))\n  ([[a b c] line-feed?]\n   (str a \&quot; \&quot; b \&quot; \&quot; c \&quot; \&quot; (when line-feed? \&quot;\\n\&quot;))))&quot;, :offset 107, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(defn string\n  ([v] (string v false))\n  ([[a b c] line-feed?]\n   (str a \&quot; \&quot; b \&quot; \&quot; c \&quot; \&quot; (when line-feed? \&quot;\\n\&quot;))))&quot;, :offset 113, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(me.grison.raytraclj.vec/string [0 1 2])&quot;, :offset 40, :ns &quot;user&quot;} {:command &quot;(defn simple-background []\n  (let [nx 200 ny 100]\n    (raytrace 200 100\n              (for [j (range (dec ny) -1 -1)\n                    i (range 0 nx)\n                    :let [r (int (* 255.99 (/ i nx)))\n                          g (int (* 255.99 (/ j ny)))\n                          b (int (* 255.99 0.2))]]\n                (vec/string [r g b]))\n              \&quot;/mnt/c/temp/background.jpg\&quot;)))&quot;, :offset 394, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn / [[a1 a2 a3] [b1 b2 b3]]\n  [(clj// a1 b1) (clj// a2 b2) (clj// a3 b3)])&quot;, :offset 78, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(get [1 2 3] 1)&quot;, :offset 15, :ns &quot;user&quot;} {:command &quot;(get [1 2 3] 0)&quot;, :offset 15, :ns &quot;user&quot;} {:command &quot;(defn origin [ray]\n  (:origin ray))&quot;, :offset 35, :ns &quot;me.grison.raytraclj.ray&quot;} {:command &quot;(ns me.grison.raytraclj.ray\n  (:require [me.grison.raytraclj.vec :as vec]))&quot;, :offset 75, :ns &quot;user&quot;} {:command &quot;(defn raytrace [nx ny pixels path]\n  (let [header (ppm-header nx ny)\n        body (clojure.string/join pixels)\n        ppm (str header body)]\n    (img/save-jpg ppm path)))&quot;, :offset 171, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn color [r]\n  (let [unit-direction (vec/unit-vector (:direction r))\n        t (* 0.5 (+ (get unit-direction 1) 1.0))]\n    (vec/+ (vec/*1 [1.0 1.0 1.0] (- 1.0 t))\n           (vec/*1 [0.5 0.7 1.0] t))))&quot;, :offset 204, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn simple-background []\n  (let [nx 200 ny 100\n        lower-left-corner [-2.0 -1.0 -1.0]\n        horizontal [4.0 0.0 0.0]\n        vertical [0.0 2.0 0.0]\n        origin [0.0 0.0 0.0]]\n    (raytrace nx ny\n              (for [j (range (dec ny) -1 -1)\n                    i (range 0 nx)\n                    :let [u (/ i nx)\n                          v (/ j ny)\n                          r (ray/make origin (vec/+ lower-left-corner\n                                                    (vec/+ (vec/* u horizontal)\n                                                           (vec/* v vertical))))\n                          col (color r)\n                          ir (int (* 255.99 (get col 0)))\n                          ig (int (* 255.99 (get col 1)))\n                          ib (int (* 255.99 (get col 2)))]]\n                (vec/string [ir ig ib]))\n              \&quot;/mnt/c/temp/background.jpg\&quot;)))&quot;, :offset 893, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn simple-background []\n  (let [nx 200 ny 100\n        lower-left-corner [-2.0 -1.0 -1.0]\n        horizontal [4.0 0.0 0.0]\n        vertical [0.0 2.0 0.0]\n        origin [0.0 0.0 0.0]]\n    (raytrace nx ny\n              (for [j (range (dec ny) -1 -1)\n                    i (range 0 nx)\n                    :let [u (/ i nx)\n                          v (/ j ny)\n                          r (ray/make origin (vec/+ lower-left-corner\n                                                    (vec/+ (vec/*1 horizontal u)\n                                                           (vec/*1 vertical v))))\n                          col (color r)\n                          ir (int (* 255.99 (get col 0)))\n                          ig (int (* 255.99 (get col 1)))\n                          ib (int (* 255.99 (get col 2)))]]\n                (vec/string [ir ig ib]))\n              \&quot;/mnt/c/temp/background.jpg\&quot;)))&quot;, :offset 895, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn simple-background []\n  (let [nx 200 ny 100\n        lower-left-corner [-2.0 -1.0 -1.0]\n        horizontal [4.0 0.0 0.0]\n        vertical [0.0 2.0 0.0]\n        origin [0.0 0.0 0.0]]\n    (raytrace nx ny\n              (for [j (range (dec ny) -1 -1)\n                    i (range 0 nx)\n                    :let [u (/ i nx)\n                          v (/ j ny)\n                          r (ray/make origin (vec/+ lower-left-corner\n                                                    (vec/+ (vec/*1 horizontal u)\n                                                           (vec/*1 vertical v))))\n                          col (color r)\n                          ir (int (* 255.99 (vec/x col)))\n                          ig (int (* 255.99 (vec/y col)))\n                          ib (int (* 255.99 (vec/z col)))]]\n                (vec/string [ir ig ib]))\n              \&quot;/mnt/c/temp/background.jpg\&quot;)))&quot;, :offset 895, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(simple-background)&quot;, :offset 19, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(map + [1 2 3])&quot;, :offset 15, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(map clj/+ [1 2 3])&quot;, :offset 19, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(defn simple-background-and-sphere []\n  (let [nx 200 ny 100\n        lower-left-corner [-2.0 -1.0 -1.0]\n        horizontal [4.0 0.0 0.0]\n        vertical [0.0 2.0 0.0]\n        origin [0.0 0.0 0.0]]\n    (raytrace nx ny\n              (for [j (range (dec ny) -1 -1)\n                    i (range 0 nx)\n                    :let [u (/ i nx)\n                          v (/ j ny)\n                          r (ray/make origin (vec/+ lower-left-corner\n                                                    (vec/+ (vec/*1 horizontal u)\n                                                           (vec/*1 vertical v))))\n                          col (color r)\n                          ir (int (* 255.99 (vec/x col)))\n                          ig (int (* 255.99 (vec/y col)))\n                          ib (int (* 255.99 (vec/z col)))]]\n                (vec/string [ir ig ib]))\n              \&quot;/mnt/c/temp/background.jpg\&quot;)))&quot;, :offset 906, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(if (ray/hit-sphere [0 0 -1] 0.5 r)\n    [1 0 0]\n    (let [unit-direction (vec/unit-vector (ray/direction r))\n          t (* 0.5 (+ (vec/y unit-direction) 1.0))]\n      (vec/+ (vec/*1 [1.0 1.0 1.0] (- 1.0 t))\n             (vec/*1 [0.5 0.7 1.0] t))))&quot;, :offset 247, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn color [r]\n  (if (ray/hit-sphere [0 0 -1] 0.5 r)\n    [1 0 0]\n    (let [unit-direction (vec/unit-vector (ray/direction r))\n          t (* 0.5 (+ (vec/y unit-direction) 1.0))]\n      (vec/+ (vec/*1 [1.0 1.0 1.0] (- 1.0 t))\n             (vec/*1 [0.5 0.7 1.0] t)))))&quot;, :offset 266, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn simple-background-and-sphere []\n  (let [nx 200 ny 100\n        lower-left-corner [-2.0 -1.0 -1.0]\n        horizontal [4.0 0.0 0.0]\n        vertical [0.0 2.0 0.0]\n        origin [0.0 0.0 0.0]]\n    (raytrace nx ny\n              (for [j (range (dec ny) -1 -1)\n                    i (range 0 nx)\n                    :let [u (/ i nx)\n                          v (/ j ny)\n                          r (ray/make origin (vec/+ lower-left-corner\n                                                    (vec/+ (vec/*1 horizontal u)\n                                                           (vec/*1 vertical v))))\n                          col (color r)\n                          ir (int (* 255.99 (vec/x col)))\n                          ig (int (* 255.99 (vec/y col)))\n                          ib (int (* 255.99 (vec/z col)))]]\n                (vec/string [ir ig ib]))\n              \&quot;/mnt/c/temp/background-sphere.jpg\&quot;)))&quot;, :offset 913, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(me.grison.raytraclj.vec/• [0.0 0.0 1.0] [-2.0 0.98 -1.0])&quot;, :offset 58, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(reduce + [1 2 3])&quot;, :offset 18, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(reduce clj/+ [1 2 3])&quot;, :offset 22, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(simple-background-and-sphere)&quot;, :offset 30, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(&lt; 0 5)&quot;, :offset 7, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(&lt; 5 0)&quot;, :offset 7, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(number? 10)&quot;, :offset 12, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(number? [10 1 2])&quot;, :offset 18, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;-5&quot;, :offset 2, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(def b 5)&quot;, :offset 9, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(- 5)&quot;, :offset 5, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(clj/- 10)&quot;, :offset 10, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(pos? 0.0)&quot;, :offset 10, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(defn color [r]\n  (let [t (ray/hit-sphere [0 0 -1] 0.5 r)]\n    (if (pos? t)\n      (let [N (vec/unit-vector (vec/- (ray/point-at-parameter r t)\n                                      [0 0 -1]))]\n        (vec/*1 (map inc N) 0.9))\n      (let [unit-direction (vec/unit-vector (ray/direction r))\n            t (* 0.5 (+ (vec/y unit-direction) 1.0))]\n        (vec/+ (vec/*1 [1.0 1.0 1.0] (- 1.0 t))\n               (vec/*1 [0.5 0.7 1.0] t))))))&quot;, :offset 436, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn color [r]\n  (let [t (ray/hit-sphere [0 0 -1] 0.5 r)]\n    (if (pos? t)\n      (let [N (vec/unit-vector (vec/- (ray/point-at-parameter r t)\n                                      [0 0 -1]))]\n        (vec/*1 (map inc N) 0.6))\n      (let [unit-direction (vec/unit-vector (ray/direction r))\n            t (* 0.5 (+ (vec/y unit-direction) 1.0))]\n        (vec/+ (vec/*1 [1.0 1.0 1.0] (- 1.0 t))\n               (vec/*1 [0.5 0.7 1.0] t))))))&quot;, :offset 436, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn color [r]\n  (let [t (ray/hit-sphere [0 0 -1] 0.5 r)]\n    (if (pos? t)\n      (let [N (vec/unit-vector (vec/- (ray/point-at-parameter r t)\n                                      [0 0 -1]))]\n        (vec/*1 (map inc N) 0.7))\n      (let [unit-direction (vec/unit-vector (ray/direction r))\n            t (* 0.5 (+ (vec/y unit-direction) 1.0))]\n        (vec/+ (vec/*1 [1.0 1.0 1.0] (- 1.0 t))\n               (vec/*1 [0.5 0.7 1.0] t))))))&quot;, :offset 436, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn simple-background-and-sphere-surface []\n  (let [nx 800 ny 400\n        lower-left-corner [-2.0 -1.0 -1.0]\n        horizontal [4.0 0.0 0.0]\n        vertical [0.0 2.0 0.0]\n        origin [0.0 0.0 0.0]]\n    (raytrace nx ny\n              (for [j (range (dec ny) -1 -1)\n                    i (range 0 nx)\n                    :let [u (/ i nx)\n                          v (/ j ny)\n                          r (ray/make origin (vec/+ lower-left-corner\n                                                    (vec/+ (vec/*1 horizontal u)\n                                                           (vec/*1 vertical v))))\n                          col (color r)\n                          ir (int (* 255.99 (vec/x col)))\n                          ig (int (* 255.99 (vec/y col)))\n                          ib (int (* 255.99 (vec/z col)))]]\n                (vec/string [ir ig ib]))\n              \&quot;/mnt/c/temp/background-sphere-surface.jpg\&quot;)))&quot;, :offset 929, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(inc 3.0)&quot;, :offset 9, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(inc 2.578)&quot;, :offset 11, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(- 0 5)&quot;, :offset 7, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(clj/- 0 5)&quot;, :offset 11, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(clj/- 5)&quot;, :offset 9, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(unit-vector [2 5 1])&quot;, :offset 21, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(+ 5 2)&quot;, :offset 7, :ns &quot;me.grison.raytraclj.vec&quot;} {:command &quot;(ns me.grison.raytraclj.hitable\n  (:require [me.grison.raytraclj.vec :as vec]\n            [me.grison.raytraclj.ray :as ray]))&quot;, :offset 125, :ns &quot;me.grison.raytraclj.hitable&quot;} {:command &quot;(defprotocol Hitable\n  \&quot;Blabla\&quot;\n  (hit [this r t-min t-max hit-record] \&quot;Method\&quot;))&quot;, :offset 81, :ns &quot;me.grison.raytraclj.hitable&quot;} {:command &quot;(defprotocol Hitable\n  \&quot;Blabla\&quot;\n  (hit [this r t-min t-max] \&quot;Method\&quot;))&quot;, :offset 70, :ns &quot;me.grison.raytraclj.hitable&quot;} {:command &quot;(defn hit-record [r t center radius]\n  (let [p (ray/point-at-parameter r t)]\n    {:t t :p p :normal (vec// (vec/- p center) radius)}))&quot;, :offset 134, :ns &quot;me.grison.raytraclj.hitable&quot;} {:command &quot;(defrecord Sphere [center radius]\n  Hitable\n  (hit [this r t-min t-max]\n    (let [oc (vec/- (ray/origin r) (:center this))\n          a (vec/• (ray/direction r) (ray/direction r))\n          b (* 2.0 (vec/• oc (ray/direction r)))\n          c (- (vec/• oc oc) (* (:radius this) (:radius this)))\n          discriminant (- (* b b) (* 4 a c))]\n      (when (pos? discriminant)\n        (let [temp (/ (- (- b) (Math/sqrt discriminant)) a)]\n          (if (and (&lt; temp t-max) (&gt; temp t-min))\n            (hit-record r temp (:center this) (:radius this))\n            (let [temp (/ (+ (- b) (Math/sqrt discriminant)) a)]\n              (when (and (&lt; temp t-max) (&gt; temp t-min))\n                (hit-record r temp (:center this) (:radius this))))))))))&quot;, :offset 737, :ns &quot;me.grison.raytraclj.hitable&quot;} {:command &quot;(defrecord Hitables [hs]\n  Hitable\n  (hit [this r t-min t-max]\n    (let [closest-so-far (atom t-max)\n          record (atom {})]\n      (for [i (range 0 (count (:hs this)))]\n        (if-let [rec (hit (get (:hs this) i) r t-min closest-so-far)]\n          (reset! closest-so-far (:t rec))\n          (reset! record rec)\n          ))\n      @rec)))&quot;, :offset 342, :ns &quot;me.grison.raytraclj.hitable&quot;} {:command &quot;(defrecord Hitables [hs]\n  Hitable\n  (hit [this r t-min t-max]\n    (let [closest-so-far (atom t-max)\n          record (atom {})]\n      (for [i (range 0 (count (:hs this)))]\n        (if-let [rec (hit (get (:hs this) i) r t-min closest-so-far)]\n          (reset! closest-so-far (:t rec))\n          (reset! record rec)\n          ))\n      @record)))&quot;, :offset 345, :ns &quot;me.grison.raytraclj.hitable&quot;} {:command &quot;(defrecord Hitables [hs]\n  Hitable\n  (hit [this r t-min t-max]\n    (let [closest-so-far (atom t-max)\n          record (atom {})]\n      (for [i (range 0 (count (:hs this)))]\n        (if-let [rec (hit (get (:hs this) i) r t-min closest-so-far)]\n          (do\n            (reset! closest-so-far (:t rec))\n            (reset! record rec))))\n      @record)))&quot;, :offset 353, :ns &quot;me.grison.raytraclj.hitable&quot;} {:command &quot;(if-let [x nil] (println \&quot;NOK\&quot;) (println \&quot;OK\&quot;))&quot;, :offset 47, :ns &quot;me.grison.raytraclj.hitable&quot;} {:command &quot;(+ 2 3)&quot;, :offset 7, :ns &quot;user&quot;} {:command &quot;(for [i (range 0 10)]\n  (println i))&quot;, :offset 36, :ns &quot;user&quot;} {:command &quot;(doseq [i (range 0 2)]\n  (println i))&quot;, :offset 37, :ns &quot;user&quot;} {:command &quot;(zero? 0.0)&quot;, :offset 11, :ns &quot;user&quot;} {:command &quot;(zero? 0)&quot;, :offset 9, :ns &quot;user&quot;} {:command &quot;(defn simple-background-and-sphere-surface []\n  (let [nx 10 ny 5\n        lower-left-corner [-2.0 -1.0 -1.0]\n        horizontal [4.0 0.0 0.0]\n        vertical [0.0 2.0 0.0]\n        origin [0.0 0.0 0.0]\n        world [(hitable/-&gt;Sphere [0 0 -1] 0.5)\n               (hitable/-&gt;Sphere [0 -100.5 -1] 100)]]\n    (raytrace nx ny\n              (for [j (range (dec ny) -1 -1)\n                    i (range 0 nx)\n                    :let [u (/ i nx)\n                          v (/ j ny)\n                          r (ray/make origin (vec/+ lower-left-corner\n                                                    (vec/+ (vec/* horizontal u)\n                                                           (vec/* vertical v))))\n                          p (ray/point-at-parameter r 2.0)\n                          col (color r world)\n                          ir (int (* 255.99 (vec/x col)))\n                          ig (int (* 255.99 (vec/y col)))\n                          ib (int (* 255.99 (vec/z col)))]]\n                (vec/string [ir ig ib]))\n              \&quot;/mnt/c/temp/background-sphere-surface-2.jpg\&quot;)))&quot;, :offset 1091, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(int 1.2799500127995E10)&quot;, :offset 24, :ns &quot;user&quot;} {:command &quot;(unchecked-int 1.2799500127995E10)&quot;, :offset 34, :ns &quot;user&quot;} {:command &quot;(defn simple-background-and-sphere-surface []\n  (let [nx 200 ny 100\n        lower-left-corner [-2.0 -1.0 -1.0]\n        horizontal [4.0 0.0 0.0]\n        vertical [0.0 2.0 0.0]\n        origin [0.0 0.0 0.0]\n        world [(hitable/-&gt;Sphere [0 0 -1] 0.5)\n               (hitable/-&gt;Sphere [0 -100.5 -1] 100)]]\n    (raytrace nx ny\n              (for [j (range (dec ny) -1 -1)\n                    i (range 0 nx)\n                    :let [u (/ i nx)\n                          v (/ j ny)\n                          r (ray/make origin (vec/+ lower-left-corner\n                                                    (vec/+ (vec/* horizontal u)\n                                                           (vec/* vertical v))))\n                          p (ray/point-at-parameter r 2.0)\n                          col (color r world)\n                          ir (unchecked-int (* 255.99 (vec/x col)))\n                          ig (unchecked-int (* 255.99 (vec/y col)))\n                          ib (unchecked-int (* 255.99 (vec/z col)))]]\n                (vec/string [ir ig ib]))\n              \&quot;/mnt/c/temp/background-sphere-surface-2.jpg\&quot;)))&quot;, :offset 1124, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(me.grison.raytraclj.vec/- [-0.22792407799438733 0.11396203899719366 -0.5698101949859684] [0 0 -1])&quot;, :offset 99, :ns &quot;user&quot;} {:command &quot;(me.grison.raytraclj.vec/* [-0.22792407799438733 0.11396203899719366 0.4301898050140316] (/ 1 0.5))&quot;, :offset 99, :ns &quot;user&quot;} {:command &quot;(simple-background-and-sphere-surface)&quot;, :offset 38, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn random-in-unit-sphere []\n  (loop [p (atom nil)]\n    (reset! p (vec/- \n               (vec/* [(drand-48) (drand-48) (drand-48)] 2.0)\n               [1.0 1.0 1.0]))\n    (when (&gt;= (vec/squared-length @p) 1.0)\n      (recur))))&quot;, :offset 228, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(def random (Random.))\n(defn drand-48 []\n  (.nextFloat random))&quot;, :offset 63, :ns &quot;user&quot;} {:command &quot;(def random (java.util.Random.))&quot;, :offset 32, :ns &quot;user&quot;} {:command &quot;(defn drand-48 []\n  (.nextFloat random))&quot;, :offset 40, :ns &quot;user&quot;} {:command &quot;(drand-48)&quot;, :offset 10, :ns &quot;user&quot;} {:command &quot;\n(defn random-in-unit-sphere []\n  (loop [p (atom nil)]\n    (reset! p (vec/-\n                (vec/* [(drand-48) (drand-48) (drand-48)] 2.0)\n                [1.0 1.0 1.0]))\n    (when (&gt;= (vec/squared-length @p) 1.0)\n      (recur p))))&quot;, :offset 232, :ns &quot;user&quot;} {:command &quot;(defn random-in-unit-sphere []\n  (loop [p (atom nil)]\n    (reset! p (vec/-\n                (vec/* [(drand-48) (drand-48) (drand-48)] 2.0)\n                [1.0 1.0 1.0]))\n    (when (&gt;= (vec/squared-length @p) 1.0)\n      (recur p))))&quot;, :offset 231, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(vec/-\n  (vec/* [(drand-48) (drand-48) (drand-48)] 2.0)\n  [1.0 1.0 1.0])&quot;, :offset 72, :ns &quot;user&quot;} {:command &quot;(defn random-in-unit-sphere []\n  (let [rand-vec #((vec/-\n                     (vec/* [(drand-48) (drand-48) (drand-48)] 2.0)\n                     [1.0 1.0 1.0]))\n        p (atom nil)]\n    (do\n      (reset! p (rand-vec))\n      (while (&gt;= (vec/squared-length @p) 1.0)\n        (reset! p (rand-vec))))))&quot;, :offset 299, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn random-in-unit-sphere []\n  (let [rand-vec #(vec/-\n                    (vec/* [(drand-48) (drand-48) (drand-48)] 2.0)\n                    [1.0 1.0 1.0])\n        p (atom nil)]\n    (do\n      (reset! p (rand-vec))\n      (while (&gt;= (vec/squared-length @p) 1.0)\n        (reset! p (rand-vec))))))&quot;, :offset 295, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn random-in-unit-sphere []\n  (let [rand-vec #(vec/-\n                    (vec/* [(drand-48) (drand-48) (drand-48)] 2.0)\n                    [1.0 1.0 1.0])\n        p (atom nil)]\n    (do\n      (reset! p (rand-vec))\n      (println @p)\n      (while (&gt;= (vec/squared-length @p) 1.0)\n        (reset! p (rand-vec))))))&quot;, :offset 314, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn random-in-unit-sphere []\n  (let [rand-vec #(vec/-\n                    (vec/* [(drand-48) (drand-48) (drand-48)] 2.0)\n                    [1.0 1.0 1.0])\n        p (atom nil)]\n    (do\n      (reset! p (rand-vec))\n      (println @p)\n      (while (&gt;= (vec/squared-length @p) 1.0)\n        (reset! p (rand-vec))))\n    @p))&quot;, :offset 321, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(defn random-in-unit-sphere []\n  (let [rand-vec #(vec/-\n                    (vec/* [(drand-48) (drand-48) (drand-48)] 2.0)\n                    [1.0 1.0 1.0])\n        p (atom nil)]\n    (do\n      (reset! p (rand-vec))\n      (println @p)\n      (while (&gt;= (vec/squared-length @p) 1.0)\n        (reset! p (rand-vec))\n        (println @p)))\n    @p))&quot;, :offset 342, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(me.grison.raytraclj.core/random-in-unit-sphere)&quot;, :offset 48, :ns &quot;user&quot;} {:command &quot;(vec/• [1 1 1] [1 1 1])&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(time (simple-background-and-sphere-surface-antialias))&quot;, :offset 55, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(:foo nil)&quot;, :offset 10, :ns &quot;user&quot;} {:command &quot;(+ 2 nil)&quot;, :offset 9, :ns &quot;user&quot;} {:command &quot;(map? 0.5)&quot;, :offset 10, :ns &quot;user&quot;} {:command &quot;*e &quot;, :offset 3, :ns &quot;user&quot;} {:command &quot;(:res BLAH)&quot;, :offset 11, :ns &quot;user&quot;} {:command &quot;(:res @me.grison.raytraclj.core/BLAH)&quot;, :offset 37, :ns &quot;user&quot;} {:command &quot;@me.grison.raytraclj.core/BLAH&quot;, :offset 30, :ns &quot;user&quot;} {:command &quot;(* 5 3 2)&quot;, :offset 9, :ns &quot;user&quot;} {:command &quot;(simple-background-and-sphere-surface-antialias)&quot;, :offset 48, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;*e&quot;, :offset 2, :ns &quot;user&quot;} {:command &quot;(simple-background-and-sphere-metal)&quot;, :offset 36, :ns &quot;me.grison.raytraclj.core&quot;} {:command &quot;(def x (AtomicInteger. 0))&quot;, :offset 26, :ns &quot;user&quot;} {:command &quot;(.incrementAndGet x)&quot;, :offset 20, :ns &quot;user&quot;} {:command &quot;(.get x)&quot;, :offset 8, :ns &quot;user&quot;} {:command &quot;(simple-background-and-sphere-dielectric)&quot;, :offset 41, :ns &quot;me.grison.raytraclj.core&quot;}]}}</component>
  <component name="RunManager" selected="Clojure REPL.remote">
    <configuration name="Unnamed" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false" nameIsGenerated="true">
      <module name="raytraclj" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="SOCKET" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration name="remote" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <module name="raytraclj" />
      <setting name="host" value="localhost" />
      <setting name="port" value="62385" />
      <setting name="replType" value="NREPL" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Clojure REPL.Unnamed" />
      <item itemvalue="Clojure REPL.remote" />
    </list>
  </component>
  <component name="ServiceViewManager">
    <option name="viewStates">
      <list>
        <serviceView>
          <treeState>
            <expand />
            <select />
          </treeState>
        </serviceView>
      </list>
    </option>
  </component>
  <component name="StructureViewFactory">
    <option name="ACTIVE_ACTIONS" value=",ALPHA_COMPARATOR" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="b9f07ee3-7d48-422e-8842-6de6776735bb" name="Default Changelist" comment="" />
      <created>1586604023044</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1586604023044</updated>
      <workItem from="1586604027418" duration="46232000" />
    </task>
    <task id="LOCAL-00001" summary="Chapter 1: output an image">
      <created>1586607317337</created>
      <option name="number" value="00001" />
      <option name="presentableId" value="LOCAL-00001" />
      <option name="project" value="LOCAL" />
      <updated>1586607317337</updated>
    </task>
    <task id="LOCAL-00002" summary="Chapter 1: output an image">
      <created>1586607343260</created>
      <option name="number" value="00002" />
      <option name="presentableId" value="LOCAL-00002" />
      <option name="project" value="LOCAL" />
      <updated>1586607343260</updated>
    </task>
    <task id="LOCAL-00003" summary="Chapter 2: vector">
      <created>1586613022406</created>
      <option name="number" value="00003" />
      <option name="presentableId" value="LOCAL-00003" />
      <option name="project" value="LOCAL" />
      <updated>1586613022406</updated>
    </task>
    <task id="LOCAL-00004" summary="Chapter 3: Rays, a simple camera, and background">
      <created>1586615269030</created>
      <option name="number" value="00004" />
      <option name="presentableId" value="LOCAL-00004" />
      <option name="project" value="LOCAL" />
      <updated>1586615269030</updated>
    </task>
    <task id="LOCAL-00005" summary="Chapter 4: Adding a sphere">
      <created>1586616612413</created>
      <option name="number" value="00005" />
      <option name="presentableId" value="LOCAL-00005" />
      <option name="project" value="LOCAL" />
      <updated>1586616612413</updated>
    </task>
    <task id="LOCAL-00006" summary="Chapter 5: Surface normals and multiple objects">
      <created>1586620769365</created>
      <option name="number" value="00006" />
      <option name="presentableId" value="LOCAL-00006" />
      <option name="project" value="LOCAL" />
      <updated>1586620769365</updated>
    </task>
    <task id="LOCAL-00007" summary="Chapter 5: Surface normals and multiple objects - part 2">
      <created>1586637403076</created>
      <option name="number" value="00007" />
      <option name="presentableId" value="LOCAL-00007" />
      <option name="project" value="LOCAL" />
      <updated>1586637403076</updated>
    </task>
    <task id="LOCAL-00008" summary="Chapter 6: Antialiasing">
      <created>1586638897196</created>
      <option name="number" value="00008" />
      <option name="presentableId" value="LOCAL-00008" />
      <option name="project" value="LOCAL" />
      <updated>1586638897196</updated>
    </task>
    <task id="LOCAL-00009" summary="Chapter 7: Diffuse Materials">
      <created>1586642695476</created>
      <option name="number" value="00009" />
      <option name="presentableId" value="LOCAL-00009" />
      <option name="project" value="LOCAL" />
      <updated>1586642695476</updated>
    </task>
    <task id="LOCAL-00010" summary="Chapter 8: Metal">
      <created>1586698983879</created>
      <option name="number" value="00010" />
      <option name="presentableId" value="LOCAL-00010" />
      <option name="project" value="LOCAL" />
      <updated>1586698983879</updated>
    </task>
    <task id="LOCAL-00011" summary="Chapter 9: Dielectrics">
      <created>1586712281652</created>
      <option name="number" value="00011" />
      <option name="presentableId" value="LOCAL-00011" />
      <option name="project" value="LOCAL" />
      <updated>1586712281652</updated>
    </task>
    <task id="LOCAL-00012" summary="Chapter 10: Positionable camera">
      <created>1586719783655</created>
      <option name="number" value="00012" />
      <option name="presentableId" value="LOCAL-00012" />
      <option name="project" value="LOCAL" />
      <updated>1586719783655</updated>
    </task>
    <option name="localTasksCounter" value="13" />
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="VcsManagerConfiguration">
    <MESSAGE value="Chapter 1: output an image" />
    <MESSAGE value="Chapter 2: vector" />
    <MESSAGE value="Chapter 3: Rays, a simple camera, and background" />
    <MESSAGE value="Chapter 4: Adding a sphere" />
    <MESSAGE value="Chapter 5: Surface normals and multiple objects" />
    <MESSAGE value="Chapter 5: Surface normals and multiple objects - part 2" />
    <MESSAGE value="Chapter 6: Antialiasing" />
    <MESSAGE value="Chapter 7: Diffuse Materials" />
    <MESSAGE value="Chapter 8: Metal" />
    <MESSAGE value="Chapter 9: Dielectrics" />
    <MESSAGE value="Chapter 10: Positionable camera" />
    <option name="LAST_COMMIT_MESSAGE" value="Chapter 10: Positionable camera" />
  </component>
  <component name="WindowStateProjectService">
    <state x="1100" y="642" key="#com.intellij.execution.impl.EditConfigurationsDialog" timestamp="1586717924424">
      <screen x="0" y="40" width="2560" height="1400" />
    </state>
    <state x="1100" y="642" key="#com.intellij.execution.impl.EditConfigurationsDialog/0.40.2560.1400@0.40.2560.1400" timestamp="1586717924424" />
    <state x="1281" y="582" width="977" height="802" key="CommitChangelistDialog2" timestamp="1586719783125">
      <screen x="0" y="40" width="2560" height="1400" />
    </state>
    <state x="1281" y="582" width="977" height="802" key="CommitChangelistDialog2/0.40.2560.1400@0.40.2560.1400" timestamp="1586719783125" />
    <state x="1244" y="610" key="SettingsEditor" timestamp="1586717413537">
      <screen x="0" y="40" width="2560" height="1400" />
    </state>
    <state x="1244" y="610" key="SettingsEditor/0.40.2560.1400@0.40.2560.1400" timestamp="1586717413537" />
    <state x="1257" y="590" key="Vcs.Push.Dialog.v2" timestamp="1586637404231">
      <screen x="0" y="40" width="2560" height="1400" />
    </state>
    <state x="1257" y="590" key="Vcs.Push.Dialog.v2/0.40.2560.1400@0.40.2560.1400" timestamp="1586637404231" />
    <state x="1350" y="739" width="588" height="488" key="find.popup" timestamp="1586607528255">
      <screen x="0" y="40" width="2560" height="1400" />
    </state>
    <state x="1350" y="739" width="588" height="488" key="find.popup/0.40.2560.1400@0.40.2560.1400" timestamp="1586607528255" />
    <state x="956" y="722" width="687" height="678" key="search.everywhere.popup" timestamp="1586728309951">
      <screen x="0" y="40" width="2560" height="1400" />
    </state>
    <state x="956" y="722" width="687" height="678" key="search.everywhere.popup/0.40.2560.1400@0.40.2560.1400" timestamp="1586728309951" />
  </component>
</project>